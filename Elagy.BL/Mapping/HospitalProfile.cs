using AutoMapper;
using Elagy.Core.DTOs.Auth;
using Elagy.Core.DTOs.Doctor;
using Elagy.Core.DTOs.DoctorSchedule;
using Elagy.Core.DTOs.Specialty;
using Elagy.Core.DTOs.User;
using Elagy.Core.Entities;
using Elagy.Core.Enums; // For UserType, AssetType
using ServiceProvider = Elagy.Core.Entities.ServiceProvider; // Ensure this is the correct namespace for ServiceProvider
//due to the confustion that happent between the serviceprovider  injection service 
namespace Elagy.BL.Mapping
{
    public class HospitalProfile:Profile
    {
        public HospitalProfile()
        {

            CreateMap<Specialty, SpecialtyResponseDto>()
               .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.Id))
               .ForMember(dest => dest.Name, opt => opt.MapFrom(src => src.Name))
               .ForMember(dest => dest.Description, opt => opt.MapFrom(src => src.Description));

            // Map SpecialtyCreateDto to Specialty entity
            CreateMap<SpecialtyCreateDto, Specialty>()
                .ForMember(dest => dest.Id, opt => opt.Ignore())
                .ForMember(dest => dest.IsActive, opt => opt.MapFrom(src => true))
                .ForMember(dest => dest.HospitalSpecialties, opt => opt.Ignore());

            // Map SpecialtyUpdateDto to existing Specialty entity
            CreateMap<SpecialtyUpdateDto, Specialty>()
                .ForMember(dest => dest.HospitalSpecialties, opt => opt.Ignore());


            CreateMap<HospitalSpecialty, SpecialtyLinkToHospitalDto>()
               .ForMember(dest => dest.SpecialtyId, opt => opt.MapFrom(src => src.SpecialtyId))
               .ForMember(dest => dest.HospitalId, opt => opt.MapFrom(src => src.HospitalAssetId))
               // Map related entity properties (requires .Include for Specialty in repository query):
               .ForMember(dest => dest.SpecialtyName, opt => opt.MapFrom(src => src.Specialty.Name))
               .ForMember(dest => dest.SpecialtyDesc, opt => opt.MapFrom(src => src.Specialty.Description))
               // Status is derived from the global Specialty's IsActive property, as HospitalSpecialty itself doesn't have an IsActive here.
               .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Specialty.IsActive ? Status.Active : Status.Deactivated));
            ;
            CreateMap<DoctorCreateDto, Doctor>()
                .ForMember(dest => dest.Id, opt => opt.Ignore()) // ID generated by Identity
                .ForMember(dest => dest.EmailConfirmed, opt => opt.MapFrom(src => true))
                .ForMember(dest => dest.PhoneNumberConfirmed, opt => opt.MapFrom(src => true))
                .ForMember(dest => dest.TwoFactorEnabled, opt => opt.MapFrom(src => true))
                .ForMember(dest => dest.LockoutEnabled, opt => opt.MapFrom(src => true))
                .ForMember(dest => dest.AccessFailedCount, opt => opt.MapFrom(src => 0))
                .ForMember(dest => dest.UserName, opt => opt.MapFrom(src => src.Email)) // UserName is usually same as Email for Identity
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => Status.Active)) // Doctor starts as Active
                .ForMember(dest => dest.UserType, opt => opt.MapFrom(src => UserType.Doctor))
                .ForMember(dest => dest.ImageId, opt => opt.Ignore()) // Image is uploaded separately
                .ForMember(dest => dest.ImageURL, opt => opt.Ignore())
                // MedicalLicenseNumberId is mapped from MedicalLicenseNumber
                .ForMember(dest => dest.MedicalLicenseNumberId, opt => opt.MapFrom(src => src.MedicalLicenseNumber))
                // Correctly map GovernorateId (Foreign Key property on User/Doctor)
                .ForMember(dest => dest.GovernorateId, opt => opt.MapFrom(src => src.GovernorateId))
                // REMOVE THE PROBLEM LINE:
                // .ForMember(dest => dest.Governorate.CountryId, opt => opt.MapFrom(src => src.CountryId))
                // AutoMapper will not map CountryId directly to Doctor.CountryId because Doctor does not have that property.
                // The CountryId from the DTO is used for VALIDATION in the service layer (DoctorService.CreateDoctorAsync)
                // to ensure consistency between Governorate and Country, not for mapping to the Doctor entity directly.
                .ForMember(dest => dest.Governorate, opt => opt.Ignore()) // Ignore Governorate navigation property
                .ForMember(dest => dest.HospitalSpecialty, opt => opt.Ignore()) // Navigation property ignored
                .ForMember(dest => dest.Schedules, opt => opt.Ignore()) // Navigation property ignored
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore()) // Password will be set by UserManager.CreateAsync
                .ForMember(dest => dest.SecurityStamp, opt => opt.Ignore()) // Identity managed
                .ForMember(dest => dest.ConcurrencyStamp, opt => opt.Ignore()); // Identity managed


            // DoctorUpdateDto to Doctor Entity
            // NOTE: Id is not in DoctorUpdateDto, it's passed separately to the service method.
            CreateMap<DoctorUpdateDto, Doctor>()
                 // Email will be mapped by convention, allowing it to be updated.
                 .ForMember(dest => dest.UserName, opt => opt.Ignore()) // UserName usually mirrors Email, handled by service with Email
                 .ForMember(dest => dest.PasswordHash, opt => opt.Ignore()) // Password not changed via update DTO
                 .ForMember(dest => dest.SecurityStamp, opt => opt.Ignore()) // Identity managed
                 .ForMember(dest => dest.ConcurrencyStamp, opt => opt.Ignore()) // Identity managed
                 .ForMember(dest => dest.EmailConfirmed, opt => opt.Ignore()) // Status is explicitly mapped below
                 .ForMember(dest => dest.PhoneNumberConfirmed, opt => opt.Ignore()) // Status is explicitly mapped below
                 .ForMember(dest  => dest.TwoFactorEnabled, opt => opt.Ignore()) // This line has an extra 'ForMember' - check your actual code.
                 .ForMember(dest => dest.LockoutEnd, opt => opt.Ignore())
                 .ForMember(dest => dest.LockoutEnabled, opt => opt.Ignore())
                 .ForMember(dest => dest.AccessFailedCount, opt => opt.Ignore())
                 .ForMember(dest => dest.UserType, opt => opt.Ignore())
                 .ForMember(dest => dest.ImageId, opt => opt.Ignore())
                 .ForMember(dest => dest.ImageURL, opt => opt.Ignore())
                 .ForMember(dest => dest.MedicalLicenseNumberId, opt => opt.Ignore())
                 .ForMember(dest => dest.Governorate, opt => opt.Ignore()) // Navigation property ignored
                                                                           // REMOVED THE PROBLEM LINE: .ForMember(dest => dest.Governorate.Country, opt => opt.Ignore())
                 .ForMember(dest => dest.HospitalSpecialty, opt => opt.Ignore()) // Navigation property ignored
                 .ForMember(dest => dest.Schedules, opt => opt.Ignore()); // Navigation property ignored


            CreateMap<Doctor, DoctorProfileDto>()
                  .ForMember(dest => dest.SpecialtyId, opt => opt.MapFrom(src => src.HospitalSpecialty.SpecialtyId))
                  .ForMember(dest => dest.SpecialtyName, opt => opt.MapFrom(src => src.HospitalSpecialty.Specialty.Name))
                  .ForMember(dest => dest.HospitalId, opt => opt.MapFrom(src => src.HospitalSpecialty.HospitalAssetId))
                  .ForMember(dest => dest.HospitalName, opt => opt.MapFrom(src => src.HospitalSpecialty.HospitalAsset.Name))
                  // MODIFIED MAPPINGS: Map primitive properties from Governorate and Country
                  .ForMember(dest => dest.GovernorateId, opt => opt.MapFrom(src => src.Governorate.Id))
                  .ForMember(dest => dest.GovernorateName, opt => opt.MapFrom(src => src.Governorate.Name))
                  .ForMember(dest => dest.CountryId, opt => opt.MapFrom(src => src.Governorate.Country.Id))
                  .ForMember(dest => dest.CountryName, opt => opt.MapFrom(src => src.Governorate.Country.Name))
                  .ForMember(dest => dest.Email, opt => opt.MapFrom(src => src.Email ?? src.UserName));

            CreateMap<Schedule, ScheduleDto>()
            .ForMember(dest => dest.DoctorFirstName, opt => opt.MapFrom(src => src.Doctor.FirstName))
            .ForMember(dest => dest.DoctorLastName, opt => opt.MapFrom(src => src.Doctor.LastName))
            .ForMember(dest => dest.HospitalName, opt => opt.MapFrom(src => src.HospitalSpecialty.HospitalAsset.Name))
            .ForMember(dest => dest.SpecialtyName, opt => opt.MapFrom(src => src.HospitalSpecialty.Specialty.Name));



            CreateMap<Schedule, ScheduleDto>()
    .ForMember(dest => dest.DoctorFirstName, opt => opt.MapFrom(src => src.Doctor.FirstName))
    .ForMember(dest => dest.DoctorLastName, opt => opt.MapFrom(src => src.Doctor.LastName))
    .ForMember(dest => dest.HospitalName, opt => opt.MapFrom(src => src.HospitalSpecialty.HospitalAsset.Name))
    .ForMember(dest => dest.SpecialtyName, opt => opt.MapFrom(src => src.HospitalSpecialty.Specialty.Name))
    .ForMember(dest => dest.Date, opt => opt.MapFrom(src => src.Date.Date));


            // --- Mapping from DTO to Entity for Creation ---
            // This mapping is used when creating a new Schedule entity from an incoming CreateScheduleDto.
            CreateMap<CreateScheduleDto, Schedule>()
                .ForMember(dest => dest.BookedSlots, opt => opt.Ignore()) // Always 0 for new schedules
                .ForMember(dest => dest.Id, opt => opt.Ignore()) // ID is generated by DB
                .ForMember(dest => dest.Doctor, opt => opt.Ignore()) // Nav property not set from DTO
                .ForMember(dest => dest.HospitalSpecialty, opt => opt.Ignore()) // Nav property not set from DTO
             
                .ForMember(dest => dest.Date, opt => opt.MapFrom(src => src.Date.Date)); // Store only the date part


            // --- Mapping from DTO to Entity for Updates ---
            // This mapping is used when updating an existing Schedule entity from an incoming UpdateScheduleDto.
            // It uses Condition to only update properties if they are not null in the DTO (for partial updates).
            CreateMap<UpdateScheduleDto, Schedule>()
                .ForMember(dest => dest.Id, opt => opt.Ignore()) // Don't update the ID
                .ForMember(dest => dest.BookedSlots, opt => opt.Ignore()) // BookedSlots managed separately by logic
                .ForMember(dest => dest.Doctor, opt => opt.Ignore()) // Nav property not updated from DTO directly
                .ForMember(dest => dest.HospitalSpecialty, opt => opt.Ignore()) // Nav property not updated from DTO directly
               
                .ForMember(dest => dest.DoctorId, opt => opt.Condition(src => src.DoctorId != null)) // Only update if provided
                .ForMember(dest => dest.HospitalSpecialtyId, opt => opt.Condition(src => src.HospitalSpecialtyId.HasValue)) // Only update if provided
                .ForMember(dest => dest.Date, opt => opt.Condition(src => src.Date.HasValue)) // Only update if provided
                .ForMember(dest => dest.Date, opt => opt.MapFrom(src => src.Date.Value.Date)) // Map date part if present
                .ForMember(dest => dest.StartTime, opt => opt.Condition(src => src.StartTime.HasValue))
                .ForMember(dest => dest.EndTime, opt => opt.Condition(src => src.EndTime.HasValue))
                .ForMember(dest => dest.MaxCapacity, opt => opt.Condition(src => src.MaxCapacity.HasValue))
                .ForMember(dest => dest.IsActive, opt => opt.Condition(src => src.IsActive.HasValue));

        }
    }
}